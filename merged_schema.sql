-- Merged SQL Schema
-- Generated from supabase/migrations/*.sql

-- ==============================================================================
-- Source: supabase/migrations/20251212120000_remote_schema.sql
-- ==============================================================================

/*
  Skillogue Database Schema
  -------------------------
  This schema defines the structure for the Skillogue application.
  It is organized into logical sections:
  1. Reference Data
  2. Core Profiles
  3. Profile Associations
  4. Social & Interactions
  5. User Settings
*/

-- ==========================================
-- 1. Reference Data (Lookups)
-- ==========================================

CREATE TABLE IF NOT EXISTS public.languages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL UNIQUE,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.passions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL UNIQUE,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.locations (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  city text,
  region text,
  country text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- ==========================================
-- 2. Core User Profiles
-- ==========================================

CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid NOT NULL PRIMARY KEY,
  
  -- Basic Info
  first_name text,
  last_name text,
  about_me text,
  gender text,
  age integer,
  location_id bigint REFERENCES public.locations(id),
  
  -- Status & Role
  verified boolean NOT NULL DEFAULT false,
  role text DEFAULT 'user'::text,
  
  -- Privacy Settings
  is_private boolean DEFAULT false,
  show_age boolean DEFAULT true,
  show_location boolean DEFAULT true,
  
  -- Metadata
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  
  -- Foreign Key to Auth
  CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id)
);

-- ==========================================
-- 3. Profile Associations
-- ==========================================

CREATE TABLE IF NOT EXISTS public.profile_languages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  profile_id uuid NOT NULL REFERENCES public.profiles(id),
  language_id bigint NOT NULL REFERENCES public.languages(id)
);

CREATE TABLE IF NOT EXISTS public.profile_passions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  profile_id uuid NOT NULL REFERENCES public.profiles(id),
  passion_id bigint NOT NULL REFERENCES public.passions(id)
);

-- ==========================================
-- 4. Social & Interactions
-- ==========================================

CREATE TABLE IF NOT EXISTS public.messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id uuid NOT NULL REFERENCES public.profiles(id),
  receiver_id uuid NOT NULL REFERENCES public.profiles(id),
  content text NOT NULL,
  is_read boolean DEFAULT false,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.notifications (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  actor_id uuid NOT NULL REFERENCES public.profiles(id),
  type text NOT NULL,
  target_id text,
  read boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.blocks (
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  blocked_user_id uuid NOT NULL REFERENCES public.profiles(id),
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  CONSTRAINT blocks_pkey PRIMARY KEY (user_id, blocked_user_id)
);

CREATE TABLE IF NOT EXISTS public.reports (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  reporter_id uuid NOT NULL REFERENCES public.profiles(id),
  reported_user_id uuid NOT NULL REFERENCES public.profiles(id),
  reason text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- ==========================================
-- 5. User Settings & Data
-- ==========================================

CREATE TABLE IF NOT EXISTS public.saved_searches (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id),
  name text NOT NULL,
  
  -- Search Criteria
  query text,
  location text,
  min_age integer,
  max_age integer,
  language text,
  gender text,
  passion_ids bigint[],
  
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- ==========================================
-- 6. Migrations / Fixes
-- ==========================================

-- Ensure privacy columns exist (Idempotent check for existing databases)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'is_private') THEN
        ALTER TABLE public.profiles ADD COLUMN is_private boolean DEFAULT false;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'show_age') THEN
        ALTER TABLE public.profiles ADD COLUMN show_age boolean DEFAULT true;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'show_location') THEN
        ALTER TABLE public.profiles ADD COLUMN show_location boolean DEFAULT true;
    END IF;
END $$;


-- ==============================================================================
-- Source: supabase/migrations/20251212130000_add_rls_policies.sql
-- ==============================================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.blocks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.saved_searches ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profile_languages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profile_passions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.languages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.passions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

-- Profiles
CREATE POLICY "Public profiles are viewable by everyone"
ON public.profiles FOR SELECT
USING (true);

CREATE POLICY "Users can insert their own profile"
ON public.profiles FOR INSERT
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
ON public.profiles FOR UPDATE
USING (auth.uid() = id);

-- Messages
CREATE POLICY "Users can view their own messages"
ON public.messages FOR SELECT
USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can insert messages as sender"
ON public.messages FOR INSERT
WITH CHECK (auth.uid() = sender_id);

-- Blocks
CREATE POLICY "Users can view their own blocks"
ON public.blocks FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own blocks"
ON public.blocks FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own blocks"
ON public.blocks FOR DELETE
USING (auth.uid() = user_id);

-- Notifications
CREATE POLICY "Users can view their own notifications"
ON public.notifications FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own notifications"
ON public.notifications FOR UPDATE
USING (auth.uid() = user_id);

-- Saved Searches
CREATE POLICY "Users can manage their own saved searches"
ON public.saved_searches FOR ALL
USING (auth.uid() = user_id);

-- Profile Languages
CREATE POLICY "Profile languages are viewable by everyone"
ON public.profile_languages FOR SELECT
USING (true);

CREATE POLICY "Users can manage their own profile languages"
ON public.profile_languages FOR ALL
USING (auth.uid() = profile_id);

-- Profile Passions
CREATE POLICY "Profile passions are viewable by everyone"
ON public.profile_passions FOR SELECT
USING (true);

CREATE POLICY "Users can manage their own profile passions"
ON public.profile_passions FOR ALL
USING (auth.uid() = profile_id);

-- Reference Data (Read Only for users)
CREATE POLICY "Languages are viewable by everyone"
ON public.languages FOR SELECT
USING (true);

CREATE POLICY "Passions are viewable by everyone"
ON public.passions FOR SELECT
USING (true);

CREATE POLICY "Locations are viewable by everyone"
ON public.locations FOR SELECT
USING (true);

-- Reports
CREATE POLICY "Users can insert reports"
ON public.reports FOR INSERT
WITH CHECK (auth.uid() = reporter_id);

-- Note: Reports are usually viewed by admins only.


-- ==============================================================================
-- Source: supabase/migrations/20251212140000_add_indexes.sql
-- ==============================================================================

-- Add indexes for foreign keys to improve performance

-- Profiles
CREATE INDEX IF NOT EXISTS idx_profiles_location_id ON public.profiles(location_id);

-- Messages
CREATE INDEX IF NOT EXISTS idx_messages_sender_id ON public.messages(sender_id);
CREATE INDEX IF NOT EXISTS idx_messages_receiver_id ON public.messages(receiver_id);
-- Composite index for conversation queries
CREATE INDEX IF NOT EXISTS idx_messages_sender_receiver ON public.messages(sender_id, receiver_id);

-- Blocks
CREATE INDEX IF NOT EXISTS idx_blocks_user_id ON public.blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_blocks_blocked_user_id ON public.blocks(blocked_user_id);

-- Notifications
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_actor_id ON public.notifications(actor_id);

-- Saved Searches
CREATE INDEX IF NOT EXISTS idx_saved_searches_user_id ON public.saved_searches(user_id);

-- Profile Languages
CREATE INDEX IF NOT EXISTS idx_profile_languages_profile_id ON public.profile_languages(profile_id);
CREATE INDEX IF NOT EXISTS idx_profile_languages_language_id ON public.profile_languages(language_id);

-- Profile Passions
CREATE INDEX IF NOT EXISTS idx_profile_passions_profile_id ON public.profile_passions(profile_id);
CREATE INDEX IF NOT EXISTS idx_profile_passions_passion_id ON public.profile_passions(passion_id);

-- Reports
CREATE INDEX IF NOT EXISTS idx_reports_reporter_id ON public.reports(reporter_id);
CREATE INDEX IF NOT EXISTS idx_reports_reported_user_id ON public.reports(reported_user_id);

-- Locations
-- Index on country, region, city for search/filtering
CREATE INDEX IF NOT EXISTS idx_locations_country_region_city ON public.locations(country, region, city);


-- ==============================================================================
-- Source: supabase/migrations/20251212150000_launch_readiness.sql
-- ==============================================================================

-- Create verification_requests table
CREATE TABLE IF NOT EXISTS public.verification_requests (
    id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status text NOT NULL DEFAULT 'pending', -- pending, approved, rejected
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.verification_requests ENABLE ROW LEVEL SECURITY;

-- Policies for verification_requests
CREATE POLICY "Users can insert their own verification requests"
    ON public.verification_requests FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view their own verification requests"
    ON public.verification_requests FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all verification requests"
    ON public.verification_requests FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
        )
    );

CREATE POLICY "Admins can update verification requests"
    ON public.verification_requests FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
        )
    );

-- Create delete_user_account RPC function
DROP FUNCTION IF EXISTS public.delete_user_account();

CREATE OR REPLACE FUNCTION public.delete_user_account()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    requesting_user_id uuid;
BEGIN
    -- Get the ID of the user executing the function
    requesting_user_id := auth.uid();

    -- Ensure a user is logged in
    IF requesting_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Delete related data (explicitly to ensure cleanup)
    DELETE FROM public.messages WHERE sender_id = requesting_user_id OR receiver_id = requesting_user_id;
    DELETE FROM public.profile_passions WHERE profile_id = requesting_user_id;
    DELETE FROM public.profile_languages WHERE profile_id = requesting_user_id;
    DELETE FROM public.blocks WHERE user_id = requesting_user_id OR blocked_user_id = requesting_user_id;
    DELETE FROM public.reports WHERE reporter_id = requesting_user_id OR reported_user_id = requesting_user_id;
    DELETE FROM public.saved_searches WHERE user_id = requesting_user_id;
    DELETE FROM public.notifications WHERE user_id = requesting_user_id OR actor_id = requesting_user_id;
    DELETE FROM public.verification_requests WHERE user_id = requesting_user_id;
    
    -- Delete profile
    DELETE FROM public.profiles WHERE id = requesting_user_id;

    -- Delete user from auth.users
    DELETE FROM auth.users WHERE id = requesting_user_id;
END;
$$;


-- ==============================================================================
-- Source: supabase/migrations/20251212160000_messaging_functions.sql
-- ==============================================================================

-- Function to get conversations for a user
DROP FUNCTION IF EXISTS get_conversations(uuid);

CREATE OR REPLACE FUNCTION get_conversations(current_user_id uuid)
RETURNS TABLE (
    user_id uuid,
    full_name text,
    last_message text,
    unread bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    WITH last_msgs AS (
        SELECT DISTINCT ON (
            CASE WHEN sender_id = current_user_id THEN receiver_id ELSE sender_id END
        )
            id,
            CASE WHEN sender_id = current_user_id THEN receiver_id ELSE sender_id END AS other_user_id,
            content,
            created_at,
            sender_id,
            is_read
        FROM messages
        WHERE sender_id = current_user_id OR receiver_id = current_user_id
        ORDER BY 
            CASE WHEN sender_id = current_user_id THEN receiver_id ELSE sender_id END,
            created_at DESC
    ),
    unread_counts AS (
        SELECT
            sender_id,
            COUNT(*) as count
        FROM messages
        WHERE receiver_id = current_user_id AND is_read = false
        GROUP BY sender_id
    )
    SELECT
        p.id as user_id,
        (p.first_name || ' ' || COALESCE(p.last_name, '')) as full_name,
        lm.content as last_message,
        COALESCE(uc.count, 0) as unread
    FROM last_msgs lm
    JOIN profiles p ON p.id = lm.other_user_id
    LEFT JOIN unread_counts uc ON uc.sender_id = p.id
    ORDER BY lm.created_at DESC;
END;
$$;

-- Function to mark messages as read
CREATE OR REPLACE FUNCTION mark_messages_as_read(sender_id_param uuid, receiver_id_param uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE messages
    SET is_read = true
    WHERE sender_id = sender_id_param AND receiver_id = receiver_id_param AND is_read = false;
END;
$$;


-- ==============================================================================
-- Source: supabase/migrations/20251212170000_search_function.sql
-- ==============================================================================

-- Function to search profiles with filters
CREATE OR REPLACE FUNCTION search_profiles(
    p_query text DEFAULT null,
    p_location text DEFAULT null,
    p_min_age int DEFAULT null,
    p_max_age int DEFAULT null,
    p_language text DEFAULT null,
    p_gender text DEFAULT null,
    p_passion_ids bigint[] DEFAULT null,
    p_limit int DEFAULT 10,
    p_offset int DEFAULT 0,
    p_current_user_id uuid DEFAULT null
)
RETURNS TABLE (
    id uuid,
    first_name text,
    last_name text,
    about_me text,
    location text,
    age int,
    gender text,
    profile_languages text[],
    created_at timestamptz,
    profilepassions text[],
    is_private boolean,
    show_age boolean,
    show_location boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.first_name,
        p.last_name,
        p.about_me,
        (l.city || ', ' || l.country) as location,
        p.age,
        p.gender,
        ARRAY_AGG(DISTINCT lang.name) FILTER (WHERE lang.name IS NOT NULL) as profile_languages,
        p.created_at,
        ARRAY_AGG(DISTINCT pass.name) FILTER (WHERE pass.name IS NOT NULL) as profilepassions,
        p.is_private,
        p.show_age,
        p.show_location
    FROM profiles p
    LEFT JOIN locations l ON p.location_id = l.id
    LEFT JOIN profile_languages pl ON p.id = pl.profile_id
    LEFT JOIN languages lang ON pl.language_id = lang.id
    LEFT JOIN profile_passions pp ON p.id = pp.profile_id
    LEFT JOIN passions pass ON pp.passion_id = pass.id
    WHERE
        (p_current_user_id IS NULL OR p.id != p_current_user_id) -- Exclude self
        AND (p_query IS NULL OR (
            p.first_name ILIKE '%' || p_query || '%' OR
            p.last_name ILIKE '%' || p_query || '%' OR
            p.about_me ILIKE '%' || p_query || '%'
        ))
        AND (p_location IS NULL OR (
            l.city ILIKE '%' || p_location || '%' OR
            l.country ILIKE '%' || p_location || '%'
        ))
        AND (p_min_age IS NULL OR p.age >= p_min_age)
        AND (p_max_age IS NULL OR p.age <= p_max_age)
        AND (p_gender IS NULL OR p.gender = p_gender)
        AND (p_language IS NULL OR EXISTS (
            SELECT 1 FROM profile_languages pl2
            JOIN languages l2 ON pl2.language_id = l2.id
            WHERE pl2.profile_id = p.id AND l2.name ILIKE p_language
        ))
        AND (p_passion_ids IS NULL OR EXISTS (
            SELECT 1 FROM profile_passions pp2
            WHERE pp2.profile_id = p.id AND pp2.passion_id = ANY(p_passion_ids)
        ))
    GROUP BY p.id, l.city, l.country
    ORDER BY p.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;
